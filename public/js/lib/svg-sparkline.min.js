export default class SVGSparkline extends HTMLElement{static register(t){"customElements"in window&&customElements.define(t||"svg-sparkline",SVGSparkline)}static css='\n\t\t:host {\n\t\t\tdisplay: grid;\n\t\t\tdisplay: inline-grid;\n\t\t\tgrid-template-columns: 1fr 1fr;\n\t\t\tgrid-template-rows: 1fr auto;\n\t\t}\n\t\tsvg {\n\t\t\tinline-size: auto;\n\t\t\tgrid-column: 1 / 3;\n\t\t\tgrid-row: 1 / 2;\n\t\t\tpadding: var(--svg-sparkline-padding, 0.375rem);\n\t\t\toverflow: visible;\n\t\t}\n\t\t:host(:not([curve])) svg:has(title),\n\t\t:host(:not([curve="true"])) svg:has(title) {\n\t\t\toverflow-y: hidden;\n\t\t}\n\t\tsvg[aria-hidden] {\n\t\t\tpointer-events: none;\n\t\t}\n\t\tspan {\n\t\t\tpadding-inline: var(--svg-sparkline-padding, 0.375rem);\n\t\t}\n\t\tspan:nth-of-type(1) {\n\t\t\tgrid-column: 1 / 2;\n\t\t\ttext-align: start;\n\t\t}\n\t\tspan:nth-of-type(2) {\n\t\t\tgrid-column: 2 / 3;\n\t\t\ttext-align: end;\n\t\t}\n\t\t@media (prefers-reduced-motion: no-preference) {\n\t\t\t:host([animate]) {\n\t\t\t\t--duration: var(--svg-sparkline-animation-duration, var(--animation-duration, 1s));\n\t\t\t\t--first-delay: var(--svg-sparkline-animation-first-delay, var(--svg-sparkline-animation-delay, var(--animation-delay, 1s)));\n\t\t\t\t--second-delay: var(--svg-sparkline-animation-second-delay, calc(var(--duration) + var(--first-delay)));\n\t\t\t}\n\t\t\t:host([animate]) svg:first-of-type {\n\t\t\t\tclip-path: polygon(0 0, 0 0, 0 100%, 0 100%);\n\t\t\t}\n\t\t\t:host([visible]) svg:first-of-type {\n\t\t\t\tanimation: swipe var(--duration) linear var(--first-delay) forwards;\n\t\t\t}\n\t\t\t:host([animate]) svg:last-of-type,\n\t\t\t:host([animate]) span {\n\t\t\t\topacity: 0;\n\t\t\t}\n\t\t\t:host([visible]) svg:last-of-type,\n\t\t\t:host([visible]) span {\n\t\t\t\tanimation: fadein var(--duration) linear var(--second-delay) forwards;\n\t\t\t}\n\t\t}\n\t\t@keyframes swipe {\n\t\t\tto {\n\t\t\t\tclip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);\n\t\t\t}\n\t\t}\n\t\t@keyframes fadein {\n\t\t\tto {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t';static observedAttributes=["values","width","height","color","curve","endpoint","endpoint-color","endpoint-width","fill","fill-color","gradient","gradient-color","line-width","start-label","end-label","animate","animation-duration","animation-delay"];connectedCallback(){this.getAttribute("values")?this.init():console.error("Missing `values` attribute!",this)}attributeChangedCallback(){this.initTemplate(),this.setCSS()}disconnectedCallback(){this.observer&&this.observer.unobserve(this)}render(){if(!this.hasAttribute("values"))return;this.values=this.getAttribute("values").split(","),this.width=parseFloat(this.getAttribute("width"))||200,this.height=parseFloat(this.getAttribute("height"))||36,this.color=this.getAttribute("color"),this.curve=this.hasAttribute("curve")&&"false"!==this.getAttribute("curve"),this.endpoint="false"!==this.getAttribute("endpoint"),this.endpointColor=this.getAttribute("endpoint-color"),this.endpointWidth=parseFloat(this.getAttribute("endpoint-width"))||6,this.fill=this.hasAttribute("fill")&&"false"!==this.getAttribute("fill"),this.gradient=this.hasAttribute("gradient")&&"false"!==this.getAttribute("gradient"),this.gradientColor=this.getAttribute("fill-color")||this.getAttribute("gradient-color"),this.lineWidth=parseFloat(this.getAttribute("line-width"))||2,this.startLabel=this.getAttribute("start-label"),this.endLabel=this.getAttribute("end-label");const t=this.color||"var(--svg-sparkline-color, currentColor)",e=this.endpointColor||`var(--svg-sparkline-endpoint-color, ${t})`,i=this.gradientColor||`var(--svg-sparkline-fill-color, var(--svg-sparkline-gradient-color, ${t}))`;let n=[];this.startLabel&&n.push(`<span>${this.startLabel}</span>`);const s=this.title||`Sparkline ranging from ${this.getMinY(this.values)} to ${this.getMaxY(this.values)}.`;let a;return n.push(`\n\t\t<svg width="${this.width}px" height="${this.height}px" viewBox="${this.getViewBox(this.values)}" preserveAspectRatio="none" role="img">\n\t\t\t<title>${s}</title>\n\t\t`),this.gradient&&(a=this.makeID(),n.push(`\n\t\t\t<defs>\n\t\t\t\t<linearGradient id="svg-sparkline-gradient-${a}" gradientTransform="rotate(90)">\n\t\t\t\t\t<stop offset="0%" stop-color="${i}" stop-opacity="1" />\n\t\t\t\t\t<stop offset="100%" stop-color="${i}" stop-opacity="0" />\n\t\t\t\t</linearGradient>\n\t\t\t</defs>\n\t\t\t`)),(this.fill||this.gradient)&&n.push(`\n\t\t\t<path\n\t\t\t\td="${this.getPath(this.values,this.curve)} L ${this.getFinalX(this.values)} ${this.getAdjustedMaxY(this.values)} L 0 ${this.getAdjustedMaxY(this.values)} Z"\n\t\t\t\tfill="${this.fill?i:`url('#svg-sparkline-gradient-${a}')`}"\n\t\t\t\tstroke="transparent"\n\t\t\t/>\n\t\t\t`),n.push(`\n\t\t<path\n\t\t\td="${this.getPath(this.values,this.curve)}"\n\t\t\tstroke="${t}"\n\t\t\tstroke-width="${this.lineWidth}"\n\t\t\tstroke-linecap="round"\n\t\t\tfill="transparent"\n\t\t\tvector-effect="non-scaling-stroke"\n\t\t/>\n\t\t`),n.push("</svg>"),this.endpoint&&n.push(`\n\t\t\t<svg width="${this.width}px" height="${this.height}px" viewBox="0 0 ${this.width} ${this.height}" preserveAspectRatio="xMaxYMid meet" aria-hidden="true">\n\t\t\t\t<circle r="${this.endpointWidth/2}" cx="${this.width}" cy="${this.height/this.getAdjustedMaxY(this.values)*this.getFinalY(this.values)}" fill="${e}"></circle>\n\t\t\t</svg>\n\t\t\t`),this.endLabel&&n.push(`<span>${this.endLabel}</span>`),n.join("")}getBaseCSS(){let t=new CSSStyleSheet;return t.replaceSync(SVGSparkline.css),t}setCSS(){if("function"==typeof CSSStyleSheet){let t=[this.getBaseCSS()];if(this.hasAttribute("animation-duration")){let e=new CSSStyleSheet;e.replaceSync(`\n\t\t\t\t\t:host {\n\t\t\t\t\t--animation-duration: ${this.getAttribute("animation-duration")};\n\t\t\t\t\t}\n\t\t\t\t`),t.push(e)}if(this.hasAttribute("animation-delay")){let e=new CSSStyleSheet;e.replaceSync(`\n\t\t\t\t\t:host {\n\t\t\t\t\t--animation-delay: ${this.getAttribute("animation-delay")};\n\t\t\t\t\t}\n\t\t\t\t`),t.push(e)}this.shadowRoot.adoptedStyleSheets=t}}initTemplate(){if(this.shadowRoot)return void(""===this.innerHTML.trim()?this.shadowRoot.innerHTML=this.render():(this.shadowRoot.innerHTML=this.innerHTML,this.innerHTML=""));this.attachShadow({mode:"open"}),this.setCSS();let t=document.createElement("template");t.innerHTML=this.render(),this.shadowRoot.appendChild(t.content.cloneNode(!0));const e=Math.min(Math.max(Number(this.getAttribute("threshold")||.333),0),1);if(this.hasAttribute("animate")&&"function"==typeof IntersectionObserver){(this.observer=new IntersectionObserver((t,i)=>{t[0].intersectionRatio>e&&(this.setAttribute("visible",!0),i.unobserve(this))},{threshold:e})).observe(this)}}init(){this.initTemplate()}maxDecimals(t,e=2){return+t.toFixed(e)}getViewBox(t){return`0 0 ${t.length-1} ${this.getAdjustedMaxY(t)}`}lineCommand(t,e){return`L ${e},${t}`}line(t,e,i,n){const s=i-t,a=n-e;return{length:Math.sqrt(Math.pow(s,2)+Math.pow(a,2)),angle:Math.atan2(a,s)}}controlPoint(t,e,i,n,s,a,r){i=i||t,n=n||e,s=s||t,a=a||e;const h=this.line(i,n,s,a),o=h.angle+(r?Math.PI:0),l=.2*h.length;return[t+Math.cos(o)*l,e+Math.sin(o)*l]}bezierCommand(t,e,i,n){const[s,a]=this.controlPoint(e-1,i[e-1],e-2,i[e-2],e,t),[r,h]=this.controlPoint(e,t,e-1,i[e-1],e+1,i[e+1],!0);return`C ${this.maxDecimals(s)},${Math.min(n,this.maxDecimals(a))} ${this.maxDecimals(r)},${Math.min(n,this.maxDecimals(h))} ${e},${t}`}getPath(t,e){return t.map(e=>Math.max(...t)-e+1).reduce((i,n,s,a)=>s<1?"M 0,"+n:`${i} ${e?this.bezierCommand(n,s,a,this.getAdjustedMaxY(t)):this.lineCommand(n,s)}`,"")}getFinalX(t){return t.length-1}getFinalY(t){return Math.max(...t)-t[t.length-1]+1}getMinY(t){return Math.min(...t)}getMaxY(t){return Math.max(...t)}getAdjustedMaxY(t){return this.getMaxY(t)+1}makeID(){const t="0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return Array.from({length:6}).reduce((e,i)=>e+t.charAt(Math.floor(Math.random()*t.length)),"")}}SVGSparkline.register();